from __future__ import annotations
from typing import Union, Literal, Optional, List, Any

from jinja2 import Template
from pydantic import BaseModel, Field

from .question_base import QuestionBase
from .descriptors import QuestionOptionsDescriptor
from .decorators import inject_exception
from .response_validator_abc import ResponseValidatorABC
from .question_multiple_choice import BaseMultipleChoiceResponse, MultipleChoiceResponseValidator
from pydantic import BaseModel, Field

# Create a custom response model for MultipleChoiceWithOther
class BaseMultipleChoiceWithOtherResponse(BaseModel):
    """
    Base model for multiple choice with other responses.
    
    Attributes:
        answer: The selected choice
        other_text: Text for the "Other" option when selected
        comment: Optional comment field
        generated_tokens: Optional raw tokens generated by the model
    """
    answer: Any = Field(..., description="Selected choice")
    other_text: Optional[str] = Field(None, description="Specification when 'Other' is selected")
    comment: Optional[str] = Field(None, description="Optional comment field")
    generated_tokens: Optional[Any] = Field(None, description="Generated tokens")


def create_response_model_with_other(choices: List[str], permissive: bool = False):
    """
    Create a ChoiceWithOtherResponse model class with a predefined list of choices.
    
    :param choices: A list of allowed values for the answer field.
    :param permissive: If True, any value will be accepted as an answer.
    :return: A new Pydantic model class.
    """
    choice_tuple = tuple(choices)

    if not permissive:
        class ChoiceWithOtherResponse(BaseMultipleChoiceWithOtherResponse):
            """
            A model for multiple choice with other responses with strict validation.
            """
            answer: Literal[choice_tuple] = Field(description="Selected choice")

            model_config = {
                "json_schema_extra": {
                    "properties": {
                        "answer": {
                            "enum": choices
                        }
                    }
                }
            }
    else:
        class ChoiceWithOtherResponse(BaseMultipleChoiceWithOtherResponse):
            """
            A model for multiple choice with other responses with permissive validation.
            """
            answer: Any = Field(description=f"Selected choice (can be any value). Suggested choices are: {choices}")

            model_config = {
                "title": "PermissiveChoiceWithOtherResponse"
            }

    return ChoiceWithOtherResponse


class MultipleChoiceWithOtherResponseValidator(MultipleChoiceResponseValidator):
    """
    Validator for multiple choice with "other" responses.
    
    This validator extends the MultipleChoiceResponseValidator to handle
    the case where a user selects "Other" and provides a custom response.
    
    Examples:
        >>> from edsl.questions import QuestionMultipleChoiceWithOther
        >>> q = QuestionMultipleChoiceWithOther(
        ...     question_name="feeling",
        ...     question_text="How are you feeling?",
        ...     question_options=["Good", "Bad", "Neutral"],
        ...     other_option_text="Other"
        ... )
        >>> validator = q.response_validator
        >>> result = validator.validate({"answer": "Good"})
        >>> sorted(result.keys())
        ['answer', 'comment', 'generated_tokens', 'other_text']
        >>> result["answer"]
        'Good'
        >>> result = validator.validate({"answer": "Other", "other_text": "Excited"})
        >>> sorted(result.keys())
        ['answer', 'comment', 'generated_tokens', 'other_text']
        >>> result["answer"]
        'Other'
        >>> result["other_text"]
        'Excited'
    """
    required_params = ["question_options", "use_code", "other_option_text"]

    def validate(self, response_dict, verbose=False):
        """
        Validate the response according to the schema.
        
        This overrides the parent validate method to handle the "Other" option specially.
        If the answer is "Other", the other_text field should be present.
        
        Parameters:
            response_dict: The response to validate
            verbose: Whether to print debug information
            
        Returns:
            A validated response dict
        """
        # First check if this is a response with "Other" selected but missing other_text
        answer = response_dict.get("answer")
        if answer == self.other_option_text and "other_text" not in response_dict:
            # Try to extract other_text from the comment or generated_tokens
            if "comment" in response_dict and response_dict["comment"]:
                # Move comment to other_text if "Other" is selected
                response_dict["other_text"] = response_dict["comment"]
                if verbose:
                    print(f"Extracted other_text from comment: {response_dict['other_text']}")
            
        # Now use the parent validation
        return super().validate(response_dict, verbose)
    
    def fix(self, response, verbose=False):
        """
        Attempt to fix an invalid multiple choice with other response.
        
        Extends the MultipleChoiceResponseValidator fix method to also
        handle "Other" responses with custom text.
        
        Parameters:
            response: The invalid response to fix
            verbose: Whether to print debug information
            
        Returns:
            A fixed response dict if possible, otherwise the original response
        """
        # Check if this is an "Other" response with additional text
        response_text = str(response.get("answer", ""))
        
        # If the response is not in question_options but contains the other option text,
        # it might be an "Other" response with custom text
        if (response_text not in self.question_options and 
            self.other_option_text.lower() in response_text.lower()):
            
            # Try to extract the custom text after "Other"
            parts = response_text.split(":", 1)
            if len(parts) > 1 and parts[0].strip().lower() == self.other_option_text.lower():
                other_text = parts[1].strip()
                
                if verbose:
                    print(f"Identified as 'Other' response with text: {other_text}")
                
                proposed_data = {
                    "answer": self.other_option_text,
                    "other_text": other_text,
                    "comment": response.get("comment"),
                    "generated_tokens": response.get("generated_tokens"),
                }
                
                try:
                    # Validate the fixed answer
                    self.response_model.model_validate(proposed_data)
                    if verbose:
                        print(f"Fixed answer as 'Other' with text: {other_text}")
                    return proposed_data
                except Exception as e:
                    if verbose:
                        print(f"Validation failed for 'Other' answer: {e}")
        
        # If not an "Other" response or validation failed, try the parent class fix method
        return super().fix(response, verbose)

    valid_examples = [
        ({"answer": "Good"}, {"question_options": ["Good", "Great", "OK", "Bad"], "other_option_text": "Other"}),
        ({"answer": "Other", "other_text": "Fantastic"}, {"question_options": ["Good", "Great", "OK", "Bad"], "other_option_text": "Other"})
    ]

    invalid_examples = [
        (
            {"answer": "Terrible"},
            {"question_options": ["Good", "Great", "OK", "Bad"], "other_option_text": "Other"},
            "Value error, Permitted values are 'Good', 'Great', 'OK', 'Bad', 'Other'",
        ),
        (
            {"answer": "Other", "other_text": ""},
            {"question_options": ["Good", "Great", "OK", "Bad"], "other_option_text": "Other"},
            "When selecting 'Other', you must provide text in the other_text field",
        ),
    ]


class QuestionMultipleChoiceWithOther(QuestionBase):
    """
    A question that prompts the agent to select one option from a list of choices or specify "Other".
    
    QuestionMultipleChoiceWithOther extends QuestionMultipleChoice to include an "Other" option
    that allows the agent to provide a custom response when none of the predefined options
    are suitable. This is especially useful for surveys and open-ended questions where
    you want to capture responses that don't fit into predefined categories.
    
    Key Features:
    - All features of QuestionMultipleChoice
    - Additional "Other" option with free-text field
    - Customizable text for the "Other" option
    - Validation ensures that when "Other" is selected, a text explanation is provided
    
    Technical Details:
    - Uses extended Pydantic models for validation
    - Preserves all functionality of QuestionMultipleChoice
    - Adds 'other_text' field for custom responses
    
    Examples:
        Basic usage:
        
        ```python
        q = QuestionMultipleChoiceWithOther(
            question_name="preference",
            question_text="Which color do you prefer?",
            question_options=["Red", "Green", "Blue", "Yellow"]
        )
        ```
        
        Custom "Other" option text:
        
        ```python
        q = QuestionMultipleChoiceWithOther(
            question_name="preference",
            question_text="Which color do you prefer?",
            question_options=["Red", "Green", "Blue", "Yellow"],
            other_option_text="Something else (please specify)"
        )
        ```
    """

    question_type = "multiple_choice_with_other"
    purpose = "When options are known but you want to allow for custom responses"
    question_options: Union[list[str], list[list], list[float], list[int]] = (
        QuestionOptionsDescriptor()
    )
    _response_model = None
    response_validator_class = MultipleChoiceWithOtherResponseValidator

    def __init__(
        self,
        question_name: str,
        question_text: str,
        question_options: Union[list[str], list[list], list[float], list[int]],
        include_comment: bool = True,
        use_code: bool = False,
        answering_instructions: Optional[str] = None,
        question_presentation: Optional[str] = None,
        permissive: bool = False,
        other_option_text: str = "Other",
        other_instructions: Optional[str] = None,
    ):
        """
        Initialize a new multiple choice with "Other" question.
        
        Parameters
        ----------
        question_name : str
            The name of the question, used as an identifier. Must be a valid Python variable name.
            
        question_text : str
            The actual text of the question to be asked.
            
        question_options : Union[list[str], list[list], list[float], list[int]]
            The list of options the agent can select from. The "Other" option will be
            automatically added to this list.
            
        include_comment : bool, default=True
            Whether to include a comment field in the response.
            
        use_code : bool, default=False
            If True, the answer will be the index of the selected option (0-based) instead of
            the option text itself.
            
        answering_instructions : Optional[str], default=None
            Custom instructions for how the model should answer the question.
            
        question_presentation : Optional[str], default=None
            Custom template for how the question is presented to the model.
            
        permissive : bool, default=False
            If True, the validator will accept answers that are not in the provided options list.
            
        other_option_text : str, default="Other"
            The text to use for the "Other" option. This will be added to the list of options.
            
        other_instructions : Optional[str], default=None
            Custom instructions for how to provide the "Other" response. If None,
            default instructions will be used.
            
        Examples
        --------
        >>> q = QuestionMultipleChoiceWithOther(
        ...     question_name="color_preference",
        ...     question_text="What is your favorite color?",
        ...     question_options=["Red", "Blue", "Green", "Yellow"],
        ...     other_option_text="Something else (please specify)"
        ... )
        """
        # Initialize base attributes from QuestionBase
        self.question_name = question_name
        self.question_text = question_text
        self.question_options = question_options

        # Add other specific attributes
        self._include_comment = include_comment
        self.use_code = use_code
        self.answering_instructions = answering_instructions
        self.question_presentation = question_presentation
        self.permissive = permissive
        self.other_option_text = other_option_text
        self.other_instructions = other_instructions

    def create_response_model(self, replacement_dict: dict = None):
        """Create a response model that allows for the 'Other' option."""
        if replacement_dict is None:
            replacement_dict = {}

        # Create options list with "Other" option added
        options_with_other = list(self.question_options) + [self.other_option_text]

        if self.use_code:
            return create_response_model_with_other(
                list(range(len(options_with_other))), self.permissive
            )
        else:
            return create_response_model_with_other(options_with_other, self.permissive)

    @property
    def question_html_content(self) -> str:
        """Return the HTML version of the question with the Other option."""
        if hasattr(self, "option_labels"):
            option_labels = self.option_labels
        else:
            option_labels = {}
            
        # Create a list of all options including the "Other" option
        all_options = list(self.question_options) + [self.other_option_text]
            
        question_html_content = Template(
            """
        {% for option in question_options %} 
        <div>
        <input type="radio" id="{{ option }}" name="{{ question_name }}" value="{{ option }}">
        <label for="{{ option }}">
        {{ option }}
        {% if option in option_labels %}
        : {{ option_labels[option] }}
        {% endif %}
        </label>
        </div>
        {% endfor %}
        
        <div>
        <input type="radio" id="{{ other_option }}" name="{{ question_name }}" value="{{ other_option }}">
        <label for="{{ other_option }}">{{ other_option }}</label>
        <input type="text" id="{{ question_name }}_other_text" name="{{ question_name }}_other_text" 
               placeholder="Please specify" style="display:none;">
        </div>
        
        <script>
        document.getElementById('{{ other_option }}').addEventListener('change', function() {
            document.getElementById('{{ question_name }}_other_text').style.display = 'inline-block';
        });
        
        // Hide the text input when any other option is selected
        {% for option in question_options %}
        document.getElementById('{{ option }}').addEventListener('change', function() {
            document.getElementById('{{ question_name }}_other_text').style.display = 'none';
        });
        {% endfor %}
        </script>
        """
        ).render(
            question_name=self.question_name,
            question_options=self.question_options,
            option_labels=option_labels,
            other_option=self.other_option_text
        )
        return question_html_content

    @classmethod
    @inject_exception
    def example(cls, include_comment=False, use_code=False) -> QuestionMultipleChoiceWithOther:
        """Return an example instance."""
        return cls(
            question_text="How are you?",
            question_options=["Good", "Great", "OK", "Bad"],
            question_name="how_feeling",
            include_comment=include_comment,
            use_code=use_code,
            other_option_text="Other (please specify)"
        )


if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)