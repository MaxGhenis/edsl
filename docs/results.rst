.. _results:

Results
=======
A `Results` object is the result of running a survey. 
It is a list of individual `Result` objects, each of which represents a single response to a survey for each agent and model used.
It is not typically instantiated directly, but is returned by calling the `run` method of a `Jobs` object:

.. code-block:: python

   from edsl.jobs import Jobs

   job = Jobs.example()
   results = job.run()

This same example can also be used by calling the `example` method:

.. code-block:: python

   from edsl.results import Results

   results = Results.example()

For purposes of showing how to unpack and interact with a `Results` object, we'll use the following code to generate some results for a single survey question using some scenarios and agents:

.. code-block:: python

   from edsl.questions import QuestionMultipleChoice

   q = QuestionMultipleChoice(
      question_name = "how_feeling_yesterday", 
      question_text = "How were you feeling yesterday {{ period }}?", 
      question_options = ["Good", "Great", "OK", "Terrible"]
   )

   from edsl import Scenario 

   scenarios = [Scenario({"period": period}) for period in ["morning", "afternoon", "evening"]]

   from edsl import Agent 

   agents = [Agent(traits = {"status": status}) for status in ["joyful", "sad"]]

   from edsl import Survey 

   survey = Survey([q])

   results = survey.by(scenarios).by(agents).run()

For more details on each of the above steps, please see the relevant sections of the documentation.


Results components
^^^^^^^^^^^^^^^^^^
A `Results` object has many "columns" that can be accessed and analyzed individually or collectively.
A list of these can be viewed by calling the `columns` method on the object:

.. code-block:: python

   results.columns()

The following list will be returned for the results generated by the above code:

.. code-block:: python

   ['agent.agent_name',
   'agent.status',
   'answer.how_feeling_yesterday',
   'answer.how_feeling_yesterday_comment',
   'model.frequency_penalty',
   'model.max_tokens',
   'model.model',
   'model.presence_penalty',
   'model.temperature',
   'model.top_p',
   'model.use_cache',
   'prompt.how_feeling_yesterday_system_prompt',
   'prompt.how_feeling_yesterday_user_prompt',
   'raw_model_response.how_feeling_yesterday_raw_model_response',
   'scenario.period']

The columns include information about each *agent*, *model* and corresponding *prompts* that were used to simulate an *answer* to each question in the survey and for any question *scenario*, together with the *raw model response*.

*Agent* information:

* **agent.agent_name**: The name of the agent is a unique identifier that can be passed to the agent when it is created; otherwise, it is added automatically (in the form `Agent_0`, etc.) when results are generated.
* **agent.status**: The code above specified a "status" trait for each of 2 agents. Each agent trait created has its own column in results. (The key for the trait in the traits dict should be a valid Python key.)
For example, if we also specified an agent "persona" there would be a corresponding `agent.persona` column in the results. 

*Answer* information:

* **answer.how_feeling_yesterday**: The answer to the `how_feeling_yesterday` question.
* **answer.how_feeling_yesterday_comment**: An additional comment for the answer to the `how_feeling_yesterday` question.
A comment field is automatically included for every question in a survey (other than free text questions), to allow the LLM to optionally provide additional information about its response to the question.

*Model* information:
Each of `model` columns is a modifiable parameter of the model used to generate the answers.

* **model.frequency_penalty**: The frequency penalty for the model.
* **model.max_tokens**: The maximum number of tokens for the model.
* **model.model**: The model used.
* **model.presence_penalty**: The presence penalty for the model.
* **model.temperature**: The temperature for the model.
* **model.top_p**: The top p for the model.
* **model.use_cache**: Whether the model uses cache.

*Prompt* information:

* **prompt.how_feeling_yesterday_system_prompt**: The system prompt for the `how_feeling_yesterday` question.
* **prompt.how_feeling_yesterday_user_prompt**: The user prompt for the `how_feeling_yesterday` question.

*Raw model response* information:

* **raw_model_response.how_feeling_yesterday_raw_model_response**: The raw model response for the `how_feeling_yesterday` question.

*Scenario* information:

* **scenario.period**: The values provided for the "period" scenario for the question.


Creating tables by selecting and printing
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Each of these columns can be accessed directly by calling the `select` method, and then printed by appending the `print` method.
For example, the following code will print a table showing the `answer.how_feeling_yesterday` together with the `agent.status` and `scenario.period` columns
(because the column names are unique we can drop the `agent` and `answer` prefixes):

.. code-block:: python

   results = Results.example()
   results.select("status", "period", "how_feeling_yesterday").print()

This will print a table of the `how_feeling` column.

.. code-block:: text

   ┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃ agent   ┃ scenario  ┃ answer                 ┃
   ┃ .status ┃ .period   ┃ .how_feeling_yesterday ┃
   ┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━┩
   │ joyful  │ morning   │ Great                  │
   ├─────────┼───────────┼────────────────────────┤
   │ joyful  │ afternoon │ Great                  │
   ├─────────┼───────────┼────────────────────────┤
   │ joyful  │ evening   │ Great                  │
   ├─────────┼───────────┼────────────────────────┤
   │ sad     │ morning   │ Terrible               │
   ├─────────┼───────────┼────────────────────────┤
   │ sad     │ afternoon │ Terrible               │
   ├─────────┼───────────┼────────────────────────┤
   │ sad     │ evening   │ Terrible               │
   └─────────┴───────────┴────────────────────────┘

Filtering
^^^^^^^^^
Results can be filtered by using the `filter` method and passing it a logical expression identifying the individual results that should be selected.
For example, the following code will filter the results to those where the answer to the question is "Great" and then just print the answers comments:

.. code-block:: python

   results.filter("how_feeling_yesterday == 'Great'").select("how_feeling_yesterday_comment").print()

.. code-block:: text

   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
   ┃ answer                                                                            ┃
   ┃ .how_feeling_yesterday_comment                                                    ┃
   ┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
   │ I was feeling great yesterday morning, full of energy and ready to start the day! │
   ├───────────────────────────────────────────────────────────────────────────────────┤
   │ I was feeling great yesterday afternoon!                                          │
   ├───────────────────────────────────────────────────────────────────────────────────┤
   │ I was feeling great yesterday evening, thank you for asking!                      │
   └───────────────────────────────────────────────────────────────────────────────────┘

Interacting via SQL
^^^^^^^^^^^^^^^^^^^
We can also interact with the results via SQL using the `sql` method.

.. code-block:: python

   results.sql("select data_type, key, value from self where data_type = 'answer' limit 3", shape="long")


.. raw:: html

   You can view examples of the `sql` method in <a href="https://deepnote.com/workspace/expected-parrot-c2fa2435-01e3-451d-ba12-9c36b3b87ad9/project/Expected-Parrot-examples-b457490b-fc5d-45e1-82a5-a66e1738a4b9/notebook/Tutorial%20-%20Exploring%20Your%20Results-bb273d63fed340efab082accce308219">interactive notebooks</a>.


Exporting to other formats (pandas, CSV, etc.)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We can also export results to other formats, such as pandas DataFrames or CSV files.
The `to_pandas` method will return a pandas DataFrame:

.. code-block:: python

   results.to_pandas()

The `to_csv` method will write the results to a CSV file:

.. code-block:: python

   results.to_pandas().to_csv("results.csv")

The `to_json` method will write the results to a JSON file:

.. code-block:: python

   results.to_pandas().to_json("results.json")

.. raw:: html

   See more examples of built-in methods for analyzing and visualizing results in <a href="https://deepnote.com/workspace/expected-parrot-c2fa2435-01e3-451d-ba12-9c36b3b87ad9/project/Expected-Parrot-examples-b457490b-fc5d-45e1-82a5-a66e1738a4b9/notebook/Tutorial%20-%20Exploring%20Your%20Results-bb273d63fed340efab082accce308219">interactive notebooks</a>.


Result class
------------
.. automodule:: edsl.results.Result
   :members:
   :undoc-members:
   :show-inheritance:

Results class
-------------
.. automodule:: edsl.results.Results
   :members:
   :inherited-members:
   :exclude-members: append, clear, copy, count, extend, index, insert, pop, remove, reverse, sort, known_data_types, Mixins, main
   :undoc-members:
   :special-members: __init__


.. Dataset class
.. -------------

.. .. automodule:: edsl.results.Dataset
..    :members:
..    :undoc-members:
..    :show-inheritance:

.. ResultsDBMixin class
.. --------------------

.. .. automodule:: edsl.results.ResultsDBMixin
..    :members:
..    :undoc-members:
..    :show-inheritance:

.. ResultsExportMixin class
.. ------------------------

.. .. automodule:: edsl.results.ResultsExportMixin
..    :members:
..    :undoc-members:
..    :show-inheritance:

.. ResultsGGMixin class
.. --------------------

.. .. automodule:: edsl.results.ResultsGGMixin
..    :members:
..    :undoc-members:
..    :show-inheritance:
